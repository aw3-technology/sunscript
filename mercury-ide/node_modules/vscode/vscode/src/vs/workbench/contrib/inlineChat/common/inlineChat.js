import { localize } from '../../../../nls.js';
import { MenuId } from '../../../../platform/actions/common/actions.js';
import { Extensions } from '../../../../platform/configuration/common/configurationRegistry.js';
import { RawContextKey, ContextKeyExpr } from '../../../../platform/contextkey/common/contextkey.js';
import { Registry } from '../../../../platform/registry/common/platform.js';
import { registerColor, transparent } from '../../../../platform/theme/common/colorUtils.js';
import { focusBorder } from '../../../../platform/theme/common/colors/baseColors.js';
import '../../../../platform/theme/common/colors/chartsColors.js';
import { editorWidgetForeground, editorWidgetBackground, editorWidgetBorder, widgetShadow, diffInserted, diffRemoved } from '../../../../platform/theme/common/colors/editorColors.js';
import { inputPlaceholderForeground, inputBackground } from '../../../../platform/theme/common/colors/inputColors.js';
import '../../../../platform/theme/common/colors/listColors.js';
import '../../../../platform/theme/common/colors/menuColors.js';
import '../../../../platform/theme/common/colors/minimapColors.js';
import '../../../../platform/theme/common/colors/miscColors.js';
import '../../../../platform/theme/common/colors/quickpickColors.js';
import '../../../../platform/theme/common/colors/searchColors.js';
var InlineChatConfigKeys;
( ((function(InlineChatConfigKeys) {
    InlineChatConfigKeys["Mode"] = "inlineChat.mode";
    InlineChatConfigKeys["FinishOnType"] = "inlineChat.finishOnType";
    InlineChatConfigKeys["AcceptedOrDiscardBeforeSave"] = "inlineChat.acceptedOrDiscardBeforeSave";
    InlineChatConfigKeys["HoldToSpeech"] = "inlineChat.holdToSpeech";
    InlineChatConfigKeys["AccessibleDiffView"] = "inlineChat.accessibleDiffView";
    InlineChatConfigKeys["ExpTextButtons"] = "inlineChat.experimental.textButtons";
})(InlineChatConfigKeys || (InlineChatConfigKeys = {}))));
var EditMode;
( ((function(EditMode) {
    EditMode["Live"] = "live";
    EditMode["Preview"] = "preview";
})(EditMode || (EditMode = {}))));
( (Registry.as(Extensions.Configuration))).registerConfiguration({
    id: 'editor',
    properties: {
        [InlineChatConfigKeys.Mode]: {
            description: ( localize(
                7041,
                "Configure if changes crafted with inline chat are applied directly to the document or are previewed first."
            )),
            default: EditMode.Live,
            type: 'string',
            enum: [EditMode.Live, EditMode.Preview],
            markdownEnumDescriptions: [
                ( localize(
                    7042,
                    "Changes are applied directly to the document, can be highlighted via inline diffs, and accepted/discarded by hunks. Ending a session will keep the changes."
                )),
                ( localize(
                    7043,
                    "Changes are previewed only and need to be accepted via the apply button. Ending a session will discard the changes."
                )),
            ],
            tags: ['experimental']
        },
        [InlineChatConfigKeys.FinishOnType]: {
            description: ( localize(
                7044,
                "Whether to finish an inline chat session when typing outside of changed regions."
            )),
            default: false,
            type: 'boolean'
        },
        [InlineChatConfigKeys.AcceptedOrDiscardBeforeSave]: {
            description: ( localize(7045, "Whether pending inline chat sessions prevent saving.")),
            default: true,
            type: 'boolean'
        },
        [InlineChatConfigKeys.HoldToSpeech]: {
            description: ( localize(
                7046,
                "Whether holding the inline chat keybinding will automatically enable speech recognition."
            )),
            default: true,
            type: 'boolean'
        },
        [InlineChatConfigKeys.AccessibleDiffView]: {
            description: ( localize(
                7047,
                "Whether the inline chat also renders an accessible diff viewer for its changes."
            )),
            default: 'auto',
            type: 'string',
            enum: ['auto', 'on', 'off'],
            markdownEnumDescriptions: [
                ( localize(
                    7048,
                    "The accessible diff viewer is based screen reader mode being enabled."
                )),
                ( localize(7049, "The accessible diff viewer is always enabled.")),
                ( localize(7050, "The accessible diff viewer is never enabled.")),
            ],
        },
        [InlineChatConfigKeys.ExpTextButtons]: {
            description: ( localize(7051, "Whether to use textual buttons.")),
            default: false,
            type: 'boolean',
            tags: ['experimental']
        },
    }
});
const INLINE_CHAT_ID = 'interactiveEditor';
var InlineChatResponseType;
( ((function(InlineChatResponseType) {
    InlineChatResponseType["None"] = "none";
    InlineChatResponseType["Messages"] = "messages";
    InlineChatResponseType["MessagesAndEdits"] = "messagesAndEdits";
})(InlineChatResponseType || (InlineChatResponseType = {}))));
const CTX_INLINE_CHAT_HAS_AGENT = ( (new RawContextKey('inlineChatHasProvider', false, ( localize(7052, "Whether a provider for interactive editors exists")))));
const CTX_INLINE_CHAT_VISIBLE = ( (new RawContextKey('inlineChatVisible', false, ( localize(7053, "Whether the interactive editor input is visible")))));
const CTX_INLINE_CHAT_FOCUSED = ( (new RawContextKey('inlineChatFocused', false, ( localize(7054, "Whether the interactive editor input is focused")))));
const CTX_INLINE_CHAT_RESPONSE_FOCUSED = ( (new RawContextKey('inlineChatResponseFocused', false, ( localize(7055, "Whether the interactive widget's response is focused")))));
const CTX_INLINE_CHAT_EMPTY = ( (new RawContextKey('inlineChatEmpty', false, ( localize(7056, "Whether the interactive editor input is empty")))));
const CTX_INLINE_CHAT_INNER_CURSOR_FIRST = ( (new RawContextKey('inlineChatInnerCursorFirst', false, ( localize(
    7057,
    "Whether the cursor of the iteractive editor input is on the first line"
)))));
const CTX_INLINE_CHAT_INNER_CURSOR_LAST = ( (new RawContextKey('inlineChatInnerCursorLast', false, ( localize(
    7058,
    "Whether the cursor of the iteractive editor input is on the last line"
)))));
const CTX_INLINE_CHAT_OUTER_CURSOR_POSITION = ( (new RawContextKey('inlineChatOuterCursorPosition', '', ( localize(
    7061,
    "Whether the cursor of the outer editor is above or below the interactive editor input"
)))));
const CTX_INLINE_CHAT_HAS_STASHED_SESSION = ( (new RawContextKey('inlineChatHasStashedSession', false, ( localize(7062, "Whether interactive editor has kept a session for quick restore")))));
const CTX_INLINE_CHAT_USER_DID_EDIT = ( (new RawContextKey('inlineChatUserDidEdit', undefined, ( localize(7063, "Whether the user did changes ontop of the inline chat")))));
const CTX_INLINE_CHAT_DOCUMENT_CHANGED = ( (new RawContextKey('inlineChatDocumentChanged', false, ( localize(7064, "Whether the document has changed concurrently")))));
const CTX_INLINE_CHAT_CHANGE_HAS_DIFF = ( (new RawContextKey('inlineChatChangeHasDiff', false, ( localize(7065, "Whether the current change supports showing a diff")))));
const CTX_INLINE_CHAT_CHANGE_SHOWS_DIFF = ( (new RawContextKey('inlineChatChangeShowsDiff', false, ( localize(7066, "Whether the current change showing a diff")))));
const CTX_INLINE_CHAT_EDIT_MODE = ( (new RawContextKey('config.inlineChat.mode', EditMode.Live)));
const CTX_INLINE_CHAT_REQUEST_IN_PROGRESS = ( (new RawContextKey('inlineChatRequestInProgress', false, ( localize(7067, "Whether an inline chat request is currently in progress")))));
const CTX_INLINE_CHAT_RESPONSE_TYPE = ( (new RawContextKey('inlineChatResponseType', InlineChatResponseType.None, ( localize(
    7068,
    "What type was the responses have been receieved, nothing yet, just messages, or messaged and local edits"
)))));
const CTX_INLINE_CHAT_CONFIG_TXT_BTNS = ( (ContextKeyExpr.equals(`config.${[InlineChatConfigKeys.ExpTextButtons]}`, true)));
const ACTION_ACCEPT_CHANGES = 'inlineChat.acceptChanges';
const ACTION_REGENERATE_RESPONSE = 'inlineChat.regenerate';
const ACTION_VIEW_IN_CHAT = 'inlineChat.viewInChat';
const ACTION_TOGGLE_DIFF = 'inlineChat.toggleDiff';
const MENU_INLINE_CHAT_EXECUTE = MenuId.for('inlineChat.execute');
const MENU_INLINE_CHAT_CONTENT_STATUS = MenuId.for('inlineChat.content.status');
const MENU_INLINE_CHAT_WIDGET_STATUS = MenuId.for('inlineChatWidget.status');
const inlineChatForeground = registerColor('inlineChat.foreground', editorWidgetForeground, ( localize(7069, "Foreground color of the interactive editor widget")));
const inlineChatBackground = registerColor('inlineChat.background', editorWidgetBackground, ( localize(7070, "Background color of the interactive editor widget")));
registerColor('inlineChat.border', editorWidgetBorder, ( localize(7071, "Border color of the interactive editor widget")));
registerColor('inlineChat.shadow', widgetShadow, ( localize(7072, "Shadow color of the interactive editor widget")));
registerColor('inlineChatInput.border', editorWidgetBorder, ( localize(7073, "Border color of the interactive editor input")));
registerColor('inlineChatInput.focusBorder', focusBorder, ( localize(7074, "Border color of the interactive editor input when focused")));
registerColor('inlineChatInput.placeholderForeground', inputPlaceholderForeground, ( localize(7075, "Foreground color of the interactive editor input placeholder")));
registerColor('inlineChatInput.background', inputBackground, ( localize(7076, "Background color of the interactive editor input")));
registerColor('inlineChatDiff.inserted', ( (transparent(diffInserted, .5))), ( localize(7077, "Background color of inserted text in the interactive editor input")));
const overviewRulerInlineChatDiffInserted = registerColor('editorOverviewRuler.inlineChatInserted', { dark: ( (transparent(diffInserted, 0.6))), light: ( (transparent(diffInserted, 0.8))), hcDark: ( (transparent(diffInserted, 0.6))), hcLight: ( (transparent(diffInserted, 0.8))) }, ( localize(7078, 'Overview ruler marker color for inline chat inserted content.')));
const minimapInlineChatDiffInserted = registerColor('editorOverviewRuler.inlineChatInserted', { dark: ( (transparent(diffInserted, 0.6))), light: ( (transparent(diffInserted, 0.8))), hcDark: ( (transparent(diffInserted, 0.6))), hcLight: ( (transparent(diffInserted, 0.8))) }, ( localize(7078, 'Overview ruler marker color for inline chat inserted content.')));
registerColor('inlineChatDiff.removed', ( (transparent(diffRemoved, .5))), ( localize(7079, "Background color of removed text in the interactive editor input")));
registerColor('editorOverviewRuler.inlineChatRemoved', { dark: ( (transparent(diffRemoved, 0.6))), light: ( (transparent(diffRemoved, 0.8))), hcDark: ( (transparent(diffRemoved, 0.6))), hcLight: ( (transparent(diffRemoved, 0.8))) }, ( localize(7080, 'Overview ruler marker color for inline chat removed content.')));
export { ACTION_ACCEPT_CHANGES, ACTION_REGENERATE_RESPONSE, ACTION_TOGGLE_DIFF, ACTION_VIEW_IN_CHAT, CTX_INLINE_CHAT_CHANGE_HAS_DIFF, CTX_INLINE_CHAT_CHANGE_SHOWS_DIFF, CTX_INLINE_CHAT_CONFIG_TXT_BTNS, CTX_INLINE_CHAT_DOCUMENT_CHANGED, CTX_INLINE_CHAT_EDIT_MODE, CTX_INLINE_CHAT_EMPTY, CTX_INLINE_CHAT_FOCUSED, CTX_INLINE_CHAT_HAS_AGENT, CTX_INLINE_CHAT_HAS_STASHED_SESSION, CTX_INLINE_CHAT_INNER_CURSOR_FIRST, CTX_INLINE_CHAT_INNER_CURSOR_LAST, CTX_INLINE_CHAT_OUTER_CURSOR_POSITION, CTX_INLINE_CHAT_REQUEST_IN_PROGRESS, CTX_INLINE_CHAT_RESPONSE_FOCUSED, CTX_INLINE_CHAT_RESPONSE_TYPE, CTX_INLINE_CHAT_USER_DID_EDIT, CTX_INLINE_CHAT_VISIBLE, EditMode, INLINE_CHAT_ID, InlineChatConfigKeys, InlineChatResponseType, MENU_INLINE_CHAT_CONTENT_STATUS, MENU_INLINE_CHAT_EXECUTE, MENU_INLINE_CHAT_WIDGET_STATUS, inlineChatBackground, inlineChatForeground, minimapInlineChatDiffInserted, overviewRulerInlineChatDiffInserted };
