import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import { append, clearNode, setVisibility, isKeyboardEvent, Dimension, getTotalWidth, $ as $$1 } from '../../../../base/browser/dom.js';
import { DEFAULT_FONT_FAMILY } from '../../../../base/browser/fonts.js';
import { StandardKeyboardEvent } from '../../../../base/browser/keyboardEvent.js';
import { status } from '../../../../base/browser/ui/aria/aria.js';
import { Button } from '../../../../base/browser/ui/button/button.js';
import { Codicon } from '../../../../base/common/codicons.js';
import { Emitter } from '../../../../base/common/event.js';
import { HistoryNavigator2 } from '../../../../base/common/history.js';
import { KeyCode } from '../../../../base/common/keyCodes.js';
import { Disposable, DisposableStore } from '../../../../base/common/lifecycle.js';
import { basename, dirname } from '../../../../base/common/path.js';
import { isMacintosh } from '../../../../base/common/platform.js';
import { URI } from '../../../../base/common/uri.js';
import { EditorExtensionsRegistry } from '../../../../editor/browser/editorExtensions.js';
import { CodeEditorWidget } from '../../../../editor/browser/widget/codeEditor/codeEditorWidget.js';
import { Range } from '../../../../editor/common/core/range.js';
import { IModelService } from '../../../../editor/common/services/model.js';
import { HoverController } from '../../../../editor/contrib/hover/browser/hoverController.js';
import { localize } from '../../../../nls.js';
import { IAccessibilityService } from '../../../../platform/accessibility/common/accessibility.service.js';
import { DropdownWithPrimaryActionViewItem } from '../../../../platform/actions/browser/dropdownWithPrimaryActionViewItem.js';
import { createAndFillInActionBarActions } from '../../../../platform/actions/browser/menuEntryActionViewItem.js';
import { MenuWorkbenchToolBar, HiddenItemStrategy } from '../../../../platform/actions/browser/toolbar.js';
import { MenuItemAction, MenuId } from '../../../../platform/actions/common/actions.js';
import { IMenuService } from '../../../../platform/actions/common/actions.service.js';
import { IConfigurationService } from '../../../../platform/configuration/common/configuration.service.js';
import { IContextKeyService } from '../../../../platform/contextkey/common/contextkey.service.js';
import { IContextMenuService } from '../../../../platform/contextview/browser/contextView.service.js';
import { FileKind } from '../../../../platform/files/common/files.js';
import { registerAndCreateHistoryNavigationContext } from '../../../../platform/history/browser/contextScopedHistoryWidget.js';
import { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';
import { ServiceCollection } from '../../../../platform/instantiation/common/serviceCollection.js';
import { IKeybindingService } from '../../../../platform/keybinding/common/keybinding.service.js';
import { ILogService } from '../../../../platform/log/common/log.service.js';
import { INotificationService } from '../../../../platform/notification/common/notification.service.js';
import { IThemeService } from '../../../../platform/theme/common/themeService.service.js';
import { ResourceLabels } from '../../../browser/labels.js';
import { AccessibilityVerbositySettingId } from '../../accessibility/browser/accessibilityConfiguration.js';
import { AccessibilityCommandId } from '../../accessibility/common/accessibilityCommands.js';
import { SubmitAction, CancelAction, ChatSubmitSecondaryAgentAction } from './actions/chatExecuteActions.js';
import { ChatFollowups } from './chatFollowups.js';
import { ChatAgentLocation } from '../common/chatAgents.js';
import { IChatAgentService } from '../common/chatAgents.service.js';
import { CONTEXT_CHAT_INPUT_HAS_TEXT, CONTEXT_CHAT_INPUT_CURSOR_AT_TOP, CONTEXT_CHAT_INPUT_HAS_FOCUS, CONTEXT_IN_CHAT_INPUT } from '../common/chatContextKeys.js';
import { IChatWidgetHistoryService } from '../common/chatWidgetHistoryService.service.js';
import { getSimpleEditorOptions, getSimpleCodeEditorWidgetOptions } from '../../codeEditor/browser/simpleEditorOptions.js';
var ChatInputPart_1;
const $ = $$1;
const INPUT_EDITOR_MAX_HEIGHT = 250;
let ChatInputPart = class ChatInputPart extends Disposable {
    static { ChatInputPart_1 = this; }
    static { this.INPUT_SCHEME = 'chatSessionInput'; }
    static { this._counter = 0; }
    get attachedContext() {
        return this._attachedContext;
    }
    get inputPartHeight() {
        return this._inputPartHeight;
    }
    get inputEditor() {
        return this._inputEditor;
    }
    constructor(
    location, options, historyService, modelService, instantiationService, contextKeyService, configurationService, keybindingService, accessibilityService, logService) {
        super();
        this.location = location;
        this.options = options;
        this.historyService = historyService;
        this.modelService = modelService;
        this.instantiationService = instantiationService;
        this.contextKeyService = contextKeyService;
        this.configurationService = configurationService;
        this.keybindingService = keybindingService;
        this.accessibilityService = accessibilityService;
        this.logService = logService;
        this._onDidLoadInputState = this._register(( (new Emitter())));
        this.onDidLoadInputState = this._onDidLoadInputState.event;
        this._onDidChangeHeight = this._register(( (new Emitter())));
        this.onDidChangeHeight = this._onDidChangeHeight.event;
        this._onDidFocus = this._register(( (new Emitter())));
        this.onDidFocus = this._onDidFocus.event;
        this._onDidBlur = this._register(( (new Emitter())));
        this.onDidBlur = this._onDidBlur.event;
        this._onDidChangeContext = this._register(( (new Emitter())));
        this.onDidChangeContext = this._onDidChangeContext.event;
        this._onDidAcceptFollowup = this._register(( (new Emitter())));
        this.onDidAcceptFollowup = this._onDidAcceptFollowup.event;
        this._indexOfLastAttachedContextDeletedWithKeyboard = -1;
        this._attachedContext = ( (new Set()));
        this._onDidChangeVisibility = this._register(( (new Emitter())));
        this._contextResourceLabels = this.instantiationService.createInstance(ResourceLabels, { onDidChangeVisibility: this._onDidChangeVisibility.event });
        this.inputEditorHeight = 0;
        this.followupsDisposables = this._register(( (new DisposableStore())));
        this.attachedContextDisposables = this._register(( (new DisposableStore())));
        this._inputPartHeight = 0;
        this.inHistoryNavigation = false;
        this.inputUri = ( (URI.parse(`${ChatInputPart_1.INPUT_SCHEME}:input-${ChatInputPart_1._counter++}`)));
        this.inputEditorMaxHeight = this.options.renderStyle === 'compact' ? INPUT_EDITOR_MAX_HEIGHT / 3 : INPUT_EDITOR_MAX_HEIGHT;
        this.inputEditorHasText = CONTEXT_CHAT_INPUT_HAS_TEXT.bindTo(contextKeyService);
        this.chatCursorAtTop = CONTEXT_CHAT_INPUT_CURSOR_AT_TOP.bindTo(contextKeyService);
        this.inputEditorHasFocus = CONTEXT_CHAT_INPUT_HAS_FOCUS.bindTo(contextKeyService);
        this.history = this.loadHistory();
        this._register(this.historyService.onDidClearHistory(() => this.history = ( (new HistoryNavigator2([{ text: '' }], 50, historyKeyFn)))));
        this._register(this.configurationService.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration(AccessibilityVerbositySettingId.Chat)) {
                this.inputEditor.updateOptions({ ariaLabel: this._getAriaLabel() });
            }
        }));
    }
    loadHistory() {
        const history = this.historyService.getHistory(this.location);
        if (history.length === 0) {
            history.push({ text: '' });
        }
        return (
             (new HistoryNavigator2(history, 50, historyKeyFn))
        );
    }
    _getAriaLabel() {
        const verbose = this.configurationService.getValue(AccessibilityVerbositySettingId.Chat);
        if (verbose) {
            const kbLabel = this.keybindingService.lookupKeybinding(AccessibilityCommandId.OpenAccessibilityHelp)?.getLabel();
            return kbLabel ? ( localize(
                7014,
                "Chat Input,  Type to ask questions or type / for topics, press enter to send out the request. Use {0} for Chat Accessibility Help.",
                kbLabel
            )) : ( localize(
                7015,
                "Chat Input,  Type code here and press Enter to run. Use the Chat Accessibility Help command for more information."
            ));
        }
        return ( localize(7016, "Chat Input"));
    }
    updateState(inputState) {
        if (this.inHistoryNavigation) {
            return;
        }
        const newEntry = { text: this._inputEditor.getValue(), state: inputState };
        if (this.history.isAtEnd()) {
            this.history.replaceLast(newEntry);
        }
        else {
            this.history.replaceLast(newEntry);
            this.history.resetCursor();
        }
    }
    initForNewChatModel(inputValue, inputState) {
        this.history = this.loadHistory();
        this.history.add({ text: inputValue ?? this.history.current().text, state: inputState });
        if (inputValue) {
            this.setValue(inputValue, false);
        }
    }
    logInputHistory() {
        const historyStr = ( ([...this.history].map(entry => JSON.stringify(entry)))).join('\n');
        this.logService.info(`[${this.location}] Chat input history:`, historyStr);
    }
    setVisible(visible) {
        this._onDidChangeVisibility.fire(visible);
    }
    get element() {
        return this.container;
    }
    showPreviousValue() {
        if (this.history.isAtEnd()) {
            this.saveCurrentValue();
        }
        else {
            if (!( (this.history.has(
                { text: this._inputEditor.getValue(), state: this.history.current().state }
            )))) {
                this.saveCurrentValue();
                this.history.resetCursor();
            }
        }
        this.navigateHistory(true);
    }
    showNextValue() {
        if (this.history.isAtEnd()) {
            return;
        }
        else {
            if (!( (this.history.has(
                { text: this._inputEditor.getValue(), state: this.history.current().state }
            )))) {
                this.saveCurrentValue();
                this.history.resetCursor();
            }
        }
        this.navigateHistory(false);
    }
    navigateHistory(previous) {
        const historyEntry = previous ?
            this.history.previous() : this.history.next();
        status(historyEntry.text);
        this.inHistoryNavigation = true;
        this.setValue(historyEntry.text, true);
        this.inHistoryNavigation = false;
        this._onDidLoadInputState.fire(historyEntry.state);
        if (previous) {
            this._inputEditor.setPosition({ lineNumber: 1, column: 1 });
        }
        else {
            const model = this._inputEditor.getModel();
            if (!model) {
                return;
            }
            this._inputEditor.setPosition(getLastPosition(model));
        }
    }
    setValue(value, transient) {
        this.inputEditor.setValue(value);
        this.inputEditor.setPosition({ lineNumber: 1, column: value.length + 1 });
        if (!transient) {
            this.saveCurrentValue();
        }
    }
    saveCurrentValue() {
        const newEntry = { text: this._inputEditor.getValue(), state: this.history.current().state };
        this.history.replaceLast(newEntry);
    }
    focus() {
        this._inputEditor.focus();
    }
    hasFocus() {
        return this._inputEditor.hasWidgetFocus();
    }
    async acceptInput(isUserQuery) {
        if (isUserQuery) {
            const userQuery = this._inputEditor.getValue();
            const entry = { text: userQuery, state: this.history.current().state };
            this.history.replaceLast(entry);
            this.history.add({ text: '' });
        }
        this._onDidLoadInputState.fire({});
        if (this.accessibilityService.isScreenReaderOptimized() && isMacintosh) {
            this._acceptInputForVoiceover();
        }
        else {
            this._inputEditor.focus();
            this._inputEditor.setValue('');
        }
    }
    _acceptInputForVoiceover() {
        const domNode = this._inputEditor.getDomNode();
        if (!domNode) {
            return;
        }
        domNode.remove();
        this._inputEditor.setValue('');
        this._inputEditorElement.appendChild(domNode);
        this._inputEditor.focus();
    }
    clearContext() {
        if (this._attachedContext.size > 0) {
            const removed = Array.from(this._attachedContext);
            this._attachedContext.clear();
            this._onDidChangeContext.fire({ removed });
        }
    }
    attachContext(overwrite, ...contentReferences) {
        const removed = [];
        if (overwrite) {
            removed.push(...Array.from(this._attachedContext));
            this._attachedContext.clear();
        }
        if (contentReferences.length > 0) {
            for (const reference of contentReferences) {
                this._attachedContext.add(reference);
            }
        }
        if (removed.length > 0 || contentReferences.length > 0) {
            this.initAttachedContext(this.attachedContextContainer);
            if (!overwrite) {
                this._onDidChangeContext.fire({ removed, added: contentReferences });
            }
        }
    }
    render(container, initialValue, widget) {
        this.container = append(container, $('.interactive-input-part'));
        this.container.classList.toggle('compact', this.options.renderStyle === 'compact');
        this.followupsContainer = append(this.container, $('.interactive-input-followups'));
        this.attachedContextContainer = append(this.container, $('.chat-attached-context'));
        this.initAttachedContext(this.attachedContextContainer);
        const inputAndSideToolbar = append(this.container, $('.interactive-input-and-side-toolbar'));
        const inputContainer = append(inputAndSideToolbar, $('.interactive-input-and-execute-toolbar'));
        const inputScopedContextKeyService = this._register(this.contextKeyService.createScoped(inputContainer));
        CONTEXT_IN_CHAT_INPUT.bindTo(inputScopedContextKeyService).set(true);
        const scopedInstantiationService = this._register(this.instantiationService.createChild(( (new ServiceCollection([IContextKeyService, inputScopedContextKeyService])))));
        const { historyNavigationBackwardsEnablement, historyNavigationForwardsEnablement } = this._register(registerAndCreateHistoryNavigationContext(inputScopedContextKeyService, this));
        this.historyNavigationBackwardsEnablement = historyNavigationBackwardsEnablement;
        this.historyNavigationForewardsEnablement = historyNavigationForwardsEnablement;
        const options = getSimpleEditorOptions(this.configurationService);
        options.overflowWidgetsDomNode = this.options.editorOverflowWidgetsDomNode;
        options.readOnly = false;
        options.ariaLabel = this._getAriaLabel();
        options.fontFamily = DEFAULT_FONT_FAMILY;
        options.fontSize = 13;
        options.lineHeight = 20;
        options.padding = this.options.renderStyle === 'compact' ? { top: 2, bottom: 2 } : { top: 8, bottom: 8 };
        options.cursorWidth = 1;
        options.wrappingStrategy = 'advanced';
        options.bracketPairColorization = { enabled: false };
        options.suggest = {
            showIcons: false,
            showSnippets: false,
            showWords: true,
            showStatusBar: false,
            insertMode: 'replace',
        };
        options.scrollbar = { ...(options.scrollbar ?? {}), vertical: 'hidden' };
        options.stickyScroll = { enabled: false };
        this._inputEditorElement = append(inputContainer, $('.interactive-input-editor'));
        const editorOptions = getSimpleCodeEditorWidgetOptions();
        editorOptions.contributions?.push(...EditorExtensionsRegistry.getSomeEditorContributions([HoverController.ID]));
        this._inputEditor = this._register(scopedInstantiationService.createInstance(CodeEditorWidget, this._inputEditorElement, options, editorOptions));
        this._register(this._inputEditor.onDidChangeModelContent(() => {
            const currentHeight = Math.min(this._inputEditor.getContentHeight(), this.inputEditorMaxHeight);
            if (currentHeight !== this.inputEditorHeight) {
                this.inputEditorHeight = currentHeight;
                this._onDidChangeHeight.fire();
            }
            const model = this._inputEditor.getModel();
            const inputHasText = !!model && model.getValue().trim().length > 0;
            this.inputEditorHasText.set(inputHasText);
        }));
        this._register(this._inputEditor.onDidFocusEditorText(() => {
            this.inputEditorHasFocus.set(true);
            this._onDidFocus.fire();
            inputContainer.classList.toggle('focused', true);
        }));
        this._register(this._inputEditor.onDidBlurEditorText(() => {
            this.inputEditorHasFocus.set(false);
            inputContainer.classList.toggle('focused', false);
            this._onDidBlur.fire();
        }));
        this._register(this._inputEditor.onDidChangeCursorPosition(e => {
            const model = this._inputEditor.getModel();
            if (!model) {
                return;
            }
            const atTop = e.position.column === 1 && e.position.lineNumber === 1;
            this.chatCursorAtTop.set(atTop);
            this.historyNavigationBackwardsEnablement.set(atTop);
            this.historyNavigationForewardsEnablement.set(e.position.equals(getLastPosition(model)));
        }));
        this.toolbar = this._register(this.instantiationService.createInstance(MenuWorkbenchToolBar, inputContainer, this.options.menus.executeToolbar, {
            telemetrySource: this.options.menus.telemetrySource,
            menuOptions: {
                shouldForwardArgs: true
            },
            hiddenItemStrategy: HiddenItemStrategy.Ignore,
            actionViewItemProvider: (action, options) => {
                if (this.location === ChatAgentLocation.Panel) {
                    if ((action.id === SubmitAction.ID || action.id === CancelAction.ID) && action instanceof MenuItemAction) {
                        const dropdownAction = this.instantiationService.createInstance(MenuItemAction, { id: 'chat.moreExecuteActions', title: ( localize(7017, "More...")), icon: Codicon.chevronDown }, undefined, undefined, undefined, undefined);
                        return this.instantiationService.createInstance(ChatSubmitDropdownActionItem, action, dropdownAction);
                    }
                }
                return undefined;
            }
        }));
        this.toolbar.getElement().classList.add('interactive-execute-toolbar');
        this.toolbar.context = { widget };
        this._register(this.toolbar.onDidChangeMenuItems(() => {
            if (this.cachedDimensions && typeof this.cachedToolbarWidth === 'number' && this.cachedToolbarWidth !== this.toolbar.getItemsWidth()) {
                this.layout(this.cachedDimensions.height, this.cachedDimensions.width);
            }
        }));
        if (this.options.menus.inputSideToolbar) {
            const toolbarSide = this._register(this.instantiationService.createInstance(MenuWorkbenchToolBar, inputAndSideToolbar, this.options.menus.inputSideToolbar, {
                telemetrySource: this.options.menus.telemetrySource,
                menuOptions: {
                    shouldForwardArgs: true
                }
            }));
            this.inputSideToolbarContainer = toolbarSide.getElement();
            toolbarSide.getElement().classList.add('chat-side-toolbar');
            toolbarSide.context = { widget };
        }
        let inputModel = this.modelService.getModel(this.inputUri);
        if (!inputModel) {
            inputModel = this.modelService.createModel('', null, this.inputUri, true);
            this._register(inputModel);
        }
        this.inputModel = inputModel;
        this.inputModel.updateOptions({ bracketColorizationOptions: { enabled: false, independentColorPoolPerBracketType: false } });
        this._inputEditor.setModel(this.inputModel);
        if (initialValue) {
            this.inputModel.setValue(initialValue);
            const lineNumber = this.inputModel.getLineCount();
            this._inputEditor.setPosition({ lineNumber, column: this.inputModel.getLineMaxColumn(lineNumber) });
        }
    }
    initAttachedContext(container) {
        const oldHeight = container.offsetHeight;
        clearNode(container);
        this.attachedContextDisposables.clear();
        setVisibility(Boolean(this.attachedContext.size), this.attachedContextContainer);
        if (!this.attachedContext.size) {
            this._indexOfLastAttachedContextDeletedWithKeyboard = -1;
        }
        [...( (this.attachedContext.values()))].forEach((attachment, index) => {
            const widget = append(container, $('.chat-attached-context-attachment.show-file-icons'));
            const label = this._contextResourceLabels.create(widget, { supportIcons: true });
            const file = URI.isUri(attachment.value) ? attachment.value : attachment.value && typeof attachment.value === 'object' && 'uri' in attachment.value && URI.isUri(attachment.value.uri) ? attachment.value.uri : undefined;
            const range = attachment.value && typeof attachment.value === 'object' && 'range' in attachment.value && Range.isIRange(attachment.value.range) ? attachment.value.range : undefined;
            if (file && attachment.isFile) {
                const fileBasename = basename(file.path);
                const fileDirname = dirname(file.path);
                const friendlyName = `${fileBasename} ${fileDirname}`;
                const ariaLabel = range ? ( localize(
                    7018,
                    "Attached file, {0}, line {1} to line {2}",
                    friendlyName,
                    range.startLineNumber,
                    range.endLineNumber
                )) : ( localize(7019, "Attached file, {0}", friendlyName));
                label.setFile(file, {
                    fileKind: FileKind.FILE,
                    hidePath: true,
                    range,
                });
                widget.ariaLabel = ariaLabel;
                widget.tabIndex = 0;
            }
            else {
                const attachmentLabel = attachment.fullName ?? attachment.name;
                const withIcon = attachment.icon?.id ? `$(${attachment.icon.id}) ${attachmentLabel}` : attachmentLabel;
                label.setLabel(withIcon, undefined);
                widget.ariaLabel = ( localize(7020, "Attached context, {0}", attachment.name));
                widget.tabIndex = 0;
            }
            const clearButton = ( (new Button(widget, { supportIcons: true })));
            if (index === Math.min(this._indexOfLastAttachedContextDeletedWithKeyboard, this.attachedContext.size - 1)) {
                clearButton.focus();
            }
            this.attachedContextDisposables.add(clearButton);
            clearButton.icon = Codicon.close;
            const disp = clearButton.onDidClick((e) => {
                this._attachedContext.delete(attachment);
                disp.dispose();
                if (isKeyboardEvent(e)) {
                    const event = ( (new StandardKeyboardEvent(e)));
                    if (event.equals(KeyCode.Enter) || event.equals(KeyCode.Space)) {
                        this._indexOfLastAttachedContextDeletedWithKeyboard = index;
                    }
                }
                this._onDidChangeHeight.fire();
                this._onDidChangeContext.fire({ removed: [attachment] });
            });
            this.attachedContextDisposables.add(disp);
        });
        if (oldHeight !== container.offsetHeight) {
            this._onDidChangeHeight.fire();
        }
    }
    async renderFollowups(items, response) {
        if (!this.options.renderFollowups) {
            return;
        }
        this.followupsDisposables.clear();
        clearNode(this.followupsContainer);
        if (items && items.length > 0) {
            this.followupsDisposables.add(this.instantiationService.createInstance(ChatFollowups, this.followupsContainer, items, this.location, undefined, followup => this._onDidAcceptFollowup.fire({ followup, response })));
        }
        this._onDidChangeHeight.fire();
    }
    get contentHeight() {
        const data = this.getLayoutData();
        return data.followupsHeight + data.inputPartEditorHeight + data.inputPartVerticalPadding + data.inputEditorBorder + data.implicitContextHeight;
    }
    layout(height, width) {
        this.cachedDimensions = new Dimension(width, height);
        return this._layout(height, width);
    }
    _layout(height, width, allowRecurse = true) {
        this.initAttachedContext(this.attachedContextContainer);
        const data = this.getLayoutData();
        const inputEditorHeight = Math.min(data.inputPartEditorHeight, height - data.followupsHeight - data.inputPartVerticalPadding);
        const followupsWidth = width - data.inputPartHorizontalPadding;
        this.followupsContainer.style.width = `${followupsWidth}px`;
        this._inputPartHeight = data.followupsHeight + inputEditorHeight + data.inputPartVerticalPadding + data.inputEditorBorder + data.implicitContextHeight;
        const initialEditorScrollWidth = this._inputEditor.getScrollWidth();
        const newEditorWidth = width - data.inputPartHorizontalPadding - data.editorBorder - data.editorPadding - data.executeToolbarWidth - data.sideToolbarWidth - data.toolbarPadding;
        const newDimension = { width: newEditorWidth, height: inputEditorHeight };
        if (!this.previousInputEditorDimension || (this.previousInputEditorDimension.width !== newDimension.width || this.previousInputEditorDimension.height !== newDimension.height)) {
            this._inputEditor.layout(newDimension);
            this.previousInputEditorDimension = newDimension;
        }
        if (allowRecurse && initialEditorScrollWidth < 10) {
            return this._layout(height, width, false);
        }
    }
    getLayoutData() {
        return {
            inputEditorBorder: 2,
            followupsHeight: this.followupsContainer.offsetHeight,
            inputPartEditorHeight: Math.min(this._inputEditor.getContentHeight(), this.inputEditorMaxHeight),
            inputPartHorizontalPadding: this.options.renderStyle === 'compact' ? 8 : 40,
            inputPartVerticalPadding: this.options.renderStyle === 'compact' ? 12 : 24,
            implicitContextHeight: this.attachedContextContainer.offsetHeight,
            editorBorder: 2,
            editorPadding: 12,
            toolbarPadding: 4,
            executeToolbarWidth: this.cachedToolbarWidth = this.toolbar.getItemsWidth(),
            sideToolbarWidth: this.inputSideToolbarContainer ? getTotalWidth(this.inputSideToolbarContainer) + 4  : 0,
        };
    }
    saveState() {
        const inputHistory = [...this.history];
        this.historyService.saveHistory(this.location, inputHistory);
    }
};
ChatInputPart = ChatInputPart_1 = ( (__decorate([
    ( (__param(2, IChatWidgetHistoryService))),
    ( (__param(3, IModelService))),
    ( (__param(4, IInstantiationService))),
    ( (__param(5, IContextKeyService))),
    ( (__param(6, IConfigurationService))),
    ( (__param(7, IKeybindingService))),
    ( (__param(8, IAccessibilityService))),
    ( (__param(9, ILogService)))
], ChatInputPart)));
const historyKeyFn = (entry) => JSON.stringify(entry);
function getLastPosition(model) {
    return { lineNumber: model.getLineCount(), column: model.getLineLength(model.getLineCount()) + 1 };
}
let ChatSubmitDropdownActionItem = class ChatSubmitDropdownActionItem extends DropdownWithPrimaryActionViewItem {
    constructor(action, dropdownAction, menuService, contextMenuService, chatAgentService, contextKeyService, keybindingService, notificationService, themeService, accessibilityService) {
        super(action, dropdownAction, [], '', contextMenuService, {
            getKeyBinding: (action) => keybindingService.lookupKeybinding(action.id, contextKeyService)
        }, keybindingService, notificationService, contextKeyService, themeService, accessibilityService);
        const menu = menuService.createMenu(MenuId.ChatExecuteSecondary, contextKeyService);
        const setActions = () => {
            const secondary = [];
            createAndFillInActionBarActions(menu, { shouldForwardArgs: true }, secondary);
            const secondaryAgent = chatAgentService.getSecondaryAgent();
            if (secondaryAgent) {
                secondary.forEach(a => {
                    if (a.id === ChatSubmitSecondaryAgentAction.ID) {
                        a.label = ( localize(7021, "Send to @{0}", secondaryAgent.name));
                    }
                    return a;
                });
            }
            this.update(dropdownAction, secondary);
        };
        setActions();
        this._register(menu.onDidChange(() => setActions()));
    }
};
ChatSubmitDropdownActionItem = ( (__decorate([
    ( (__param(2, IMenuService))),
    ( (__param(3, IContextMenuService))),
    ( (__param(4, IChatAgentService))),
    ( (__param(5, IContextKeyService))),
    ( (__param(6, IKeybindingService))),
    ( (__param(7, INotificationService))),
    ( (__param(8, IThemeService))),
    ( (__param(9, IAccessibilityService)))
], ChatSubmitDropdownActionItem)));
export { ChatInputPart };
