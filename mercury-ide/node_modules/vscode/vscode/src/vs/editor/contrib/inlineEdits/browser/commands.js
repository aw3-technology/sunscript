import { Codicon } from '../../../../base/common/codicons.js';
import { KeyMod as KeyMod$1, KeyCode } from '../../../../base/common/keyCodes.js';
import { transaction, asyncTransaction } from '../../../../base/common/observableInternal/base.js';
import '../../../../base/common/observableInternal/derived.js';
import '../../../../base/common/observableInternal/autorun.js';
import '../../../../base/common/observableInternal/utils.js';
import '../../../../base/common/cancellation.js';
import '../../../../base/common/arrays.js';
import { EditorAction } from '../../../browser/editorExtensions.js';
import { EmbeddedCodeEditorWidget } from '../../../browser/widget/codeEditor/embeddedCodeEditorWidget.js';
import { EditorContextKeys } from '../../../common/editorContextKeys.js';
import { showNextInlineEditActionId, inlineEditVisible, showPreviousInlineEditActionId, inlineEditAcceptId } from './consts.js';
import { InlineEditsController } from './inlineEditsController.js';
import { localize2, localize } from '../../../../nls.js';
import { MenuId } from '../../../../platform/actions/common/actions.js';
import { ContextKeyExpr } from '../../../../platform/contextkey/common/contextkey.js';
function labelAndAlias(str) {
    return {
        label: str.value,
        alias: str.original,
    };
}
class ShowNextInlineEditAction extends EditorAction {
    static { this.ID = showNextInlineEditActionId; }
    constructor() {
        super({
            id: ShowNextInlineEditAction.ID,
            ...labelAndAlias(( localize2(5192, "Show Next Inline Edit"))),
            precondition: ( (ContextKeyExpr.and(EditorContextKeys.writable, inlineEditVisible))),
            kbOpts: {
                weight: 100,
                primary: KeyMod$1.Alt | KeyCode.BracketRight,
            },
        });
    }
    async run(accessor, editor) {
        const controller = InlineEditsController.get(editor);
        controller?.model.get()?.next();
    }
}
class ShowPreviousInlineEditAction extends EditorAction {
    static { this.ID = showPreviousInlineEditActionId; }
    constructor() {
        super({
            id: ShowPreviousInlineEditAction.ID,
            ...labelAndAlias(( localize2(5193, "Show Previous Inline Edit"))),
            precondition: ( (ContextKeyExpr.and(EditorContextKeys.writable, inlineEditVisible))),
            kbOpts: {
                weight: 100,
                primary: KeyMod$1.Alt | KeyCode.BracketLeft,
            },
        });
    }
    async run(accessor, editor) {
        const controller = InlineEditsController.get(editor);
        controller?.model.get()?.previous();
    }
}
class TriggerInlineEditAction extends EditorAction {
    constructor() {
        super({
            id: 'editor.action.inlineEdits.trigger',
            ...labelAndAlias(( localize2(5194, "Trigger Inline Edit"))),
            precondition: EditorContextKeys.writable
        });
    }
    async run(accessor, editor) {
        const controller = InlineEditsController.get(editor);
        await asyncTransaction(async (tx) => {
            await controller?.model.get()?.triggerExplicitly(tx);
        });
    }
}
class AcceptInlineEdit extends EditorAction {
    constructor() {
        super({
            id: inlineEditAcceptId,
            ...labelAndAlias(( localize2(5195, "Accept Inline Edit"))),
            precondition: inlineEditVisible,
            menuOpts: {
                menuId: MenuId.InlineEditsActions,
                title: ( localize(5196, "Accept Inline Edit")),
                group: 'primary',
                order: 1,
                icon: Codicon.check,
            },
            kbOpts: {
                primary: KeyMod$1.CtrlCmd | KeyCode.Space,
                weight: 20000,
                kbExpr: inlineEditVisible,
            }
        });
    }
    async run(accessor, editor) {
        if (editor instanceof EmbeddedCodeEditorWidget) {
            editor = editor.getParentEditor();
        }
        const controller = InlineEditsController.get(editor);
        if (controller) {
            controller.model.get()?.accept(controller.editor);
            controller.editor.focus();
        }
    }
}
class HideInlineEdit extends EditorAction {
    static { this.ID = 'editor.action.inlineEdits.hide'; }
    constructor() {
        super({
            id: HideInlineEdit.ID,
            ...labelAndAlias(( localize2(5197, "Hide Inline Edit"))),
            precondition: inlineEditVisible,
            kbOpts: {
                weight: 100,
                primary: KeyCode.Escape,
            }
        });
    }
    async run(accessor, editor) {
        const controller = InlineEditsController.get(editor);
        transaction(tx => {
            controller?.model.get()?.stop(tx);
        });
    }
}
export { AcceptInlineEdit, HideInlineEdit, ShowNextInlineEditAction, ShowPreviousInlineEditAction, TriggerInlineEditAction };
