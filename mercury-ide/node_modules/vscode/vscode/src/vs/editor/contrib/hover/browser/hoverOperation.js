import { RunOnceScheduler, createCancelableAsyncIterable } from '../../../../base/common/async.js';
import { onUnexpectedError } from '../../../../base/common/errors.js';
import { Emitter } from '../../../../base/common/event.js';
import { Disposable } from '../../../../base/common/lifecycle.js';
import { EditorOption } from '../../../common/config/editorOptions.js';
var HoverOperationState;
( (function(HoverOperationState) {
    HoverOperationState[HoverOperationState["Idle"] = 0] = "Idle";
    HoverOperationState[HoverOperationState["FirstWait"] = 1] = "FirstWait";
    HoverOperationState[HoverOperationState["SecondWait"] = 2] = "SecondWait";
    HoverOperationState[HoverOperationState["WaitingForAsync"] = 3] = "WaitingForAsync";
    HoverOperationState[HoverOperationState["WaitingForAsyncShowingLoading"] = 4] = "WaitingForAsyncShowingLoading";
})(HoverOperationState || (HoverOperationState = {})));
var HoverStartMode;
( (function(HoverStartMode) {
    HoverStartMode[HoverStartMode["Delayed"] = 0] = "Delayed";
    HoverStartMode[HoverStartMode["Immediate"] = 1] = "Immediate";
})(HoverStartMode || (HoverStartMode = {})));
var HoverStartSource;
( (function(HoverStartSource) {
    HoverStartSource[HoverStartSource["Mouse"] = 0] = "Mouse";
    HoverStartSource[HoverStartSource["Keyboard"] = 1] = "Keyboard";
})(HoverStartSource || (HoverStartSource = {})));
class HoverResult {
    constructor(value, isComplete, hasLoadingMessage) {
        this.value = value;
        this.isComplete = isComplete;
        this.hasLoadingMessage = hasLoadingMessage;
    }
}
class HoverOperation extends Disposable {
    constructor(_editor, _computer) {
        super();
        this._editor = _editor;
        this._computer = _computer;
        this._onResult = this._register(( new Emitter()));
        this.onResult = this._onResult.event;
        this._firstWaitScheduler = this._register(( new RunOnceScheduler(() => this._triggerAsyncComputation(), 0)));
        this._secondWaitScheduler = this._register(( new RunOnceScheduler(() => this._triggerSyncComputation(), 0)));
        this._loadingMessageScheduler = this._register(( new RunOnceScheduler(() => this._triggerLoadingMessage(), 0)));
        this._state = HoverOperationState.Idle;
        this._asyncIterable = null;
        this._asyncIterableDone = false;
        this._result = [];
    }
    dispose() {
        if (this._asyncIterable) {
            this._asyncIterable.cancel();
            this._asyncIterable = null;
        }
        super.dispose();
    }
    get _hoverTime() {
        return this._editor.getOption(EditorOption.hover).delay;
    }
    get _firstWaitTime() {
        return this._hoverTime / 2;
    }
    get _secondWaitTime() {
        return this._hoverTime - this._firstWaitTime;
    }
    get _loadingMessageTime() {
        return 3 * this._hoverTime;
    }
    _setState(state, fireResult = true) {
        this._state = state;
        if (fireResult) {
            this._fireResult();
        }
    }
    _triggerAsyncComputation() {
        this._setState(HoverOperationState.SecondWait);
        this._secondWaitScheduler.schedule(this._secondWaitTime);
        if (this._computer.computeAsync) {
            this._asyncIterableDone = false;
            this._asyncIterable = createCancelableAsyncIterable(token => this._computer.computeAsync(token));
            (async () => {
                try {
                    for await (const item of this._asyncIterable) {
                        if (item) {
                            this._result.push(item);
                            this._fireResult();
                        }
                    }
                    this._asyncIterableDone = true;
                    if (this._state === HoverOperationState.WaitingForAsync || this._state === HoverOperationState.WaitingForAsyncShowingLoading) {
                        this._setState(HoverOperationState.Idle);
                    }
                }
                catch (e) {
                    onUnexpectedError(e);
                }
            })();
        }
        else {
            this._asyncIterableDone = true;
        }
    }
    _triggerSyncComputation() {
        if (this._computer.computeSync) {
            this._result = this._result.concat(this._computer.computeSync());
        }
        this._setState(this._asyncIterableDone ? HoverOperationState.Idle : HoverOperationState.WaitingForAsync);
    }
    _triggerLoadingMessage() {
        if (this._state === HoverOperationState.WaitingForAsync) {
            this._setState(HoverOperationState.WaitingForAsyncShowingLoading);
        }
    }
    _fireResult() {
        if (this._state === HoverOperationState.FirstWait || this._state === HoverOperationState.SecondWait) {
            return;
        }
        const isComplete = (this._state === HoverOperationState.Idle);
        const hasLoadingMessage = (this._state === HoverOperationState.WaitingForAsyncShowingLoading);
        this._onResult.fire(( new HoverResult(this._result.slice(0), isComplete, hasLoadingMessage)));
    }
    start(mode) {
        if (mode === HoverStartMode.Delayed) {
            if (this._state === HoverOperationState.Idle) {
                this._setState(HoverOperationState.FirstWait);
                this._firstWaitScheduler.schedule(this._firstWaitTime);
                this._loadingMessageScheduler.schedule(this._loadingMessageTime);
            }
        }
        else {
            switch (this._state) {
                case HoverOperationState.Idle:
                    this._triggerAsyncComputation();
                    this._secondWaitScheduler.cancel();
                    this._triggerSyncComputation();
                    break;
                case HoverOperationState.SecondWait:
                    this._secondWaitScheduler.cancel();
                    this._triggerSyncComputation();
                    break;
            }
        }
    }
    cancel() {
        this._firstWaitScheduler.cancel();
        this._secondWaitScheduler.cancel();
        this._loadingMessageScheduler.cancel();
        if (this._asyncIterable) {
            this._asyncIterable.cancel();
            this._asyncIterable = null;
        }
        this._result = [];
        this._setState(HoverOperationState.Idle, false);
    }
}
export { HoverOperation, HoverResult, HoverStartMode, HoverStartSource };
